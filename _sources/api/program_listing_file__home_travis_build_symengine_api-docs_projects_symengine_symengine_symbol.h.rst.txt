
.. _program_listing_file__home_travis_build_symengine_api-docs_projects_symengine_symengine_symbol.h:

Program Listing for File symbol.h
=================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_symengine_api-docs_projects_symengine_symengine_symbol.h>` (``/home/travis/build/symengine/api-docs/projects/symengine/symengine/symbol.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef SYMENGINE_SYMBOL_H
   #define SYMENGINE_SYMBOL_H
   
   #include <symengine/basic.h>
   
   namespace SymEngine
   {
   
   class Symbol : public Basic
   {
   private:
       std::string name_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_SYMBOL)
       explicit Symbol(const std::string &name);
       virtual hash_t __hash__() const;
       virtual bool __eq__(const Basic &o) const;
   
       virtual int compare(const Basic &o) const;
       inline const std::string &get_name() const
       {
           return name_;
       }
   
       virtual vec_basic get_args() const
       {
           return {};
       }
       RCP<const Symbol> as_dummy() const;
   };
   
   class Dummy : public Symbol
   {
   private:
       static size_t count_;
       size_t dummy_index;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_DUMMY)
       explicit Dummy();
       explicit Dummy(const std::string &name);
       virtual hash_t __hash__() const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
       size_t get_index() const
       {
           return dummy_index;
       }
   };
   
   inline RCP<const Symbol> symbol(const std::string &name)
   {
       return make_rcp<const Symbol>(name);
   }
   
   inline RCP<const Dummy> dummy()
   {
       return make_rcp<const Dummy>();
   }
   
   inline RCP<const Dummy> dummy(const std::string &name)
   {
       return make_rcp<const Dummy>(name);
   }
   
   } // SymEngine
   
   #endif
