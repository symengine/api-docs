
.. _program_listing_file__home_travis_build_symengine_api-docs_projects_symengine_symengine_cwrapper.h:

Program Listing for File cwrapper.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_symengine_api-docs_projects_symengine_symengine_cwrapper.h>` (``/home/travis/build/symengine/api-docs/projects/symengine/symengine/cwrapper.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef CWRAPPER_H
   #define CWRAPPER_H
   
   #include <stdio.h>
   #include <stdlib.h>
   #include "symengine/symengine_config.h"
   
   #ifdef HAVE_SYMENGINE_GMP
   #include <gmp.h>
   #endif
   
   #ifdef HAVE_SYMENGINE_MPFR
   #include <mpfr.h>
   #endif // HAVE_SYMENGINE_MPFR
   
   #include "symengine/symengine_exception.h"
   
   #ifdef __cplusplus
   extern "C" {
   #endif
   
   // Use SYMENGINE_C_ASSERT in C tests
   #define SYMENGINE_C_ASSERT(cond)                                               \
       {                                                                          \
           if (0 == (cond)) {                                                     \
               printf("SYMENGINE_C_ASSERT failed: %s \nfunction %s (), line "     \
                      "number %d at\n%s\n",                                       \
                      __FILE__, __func__, __LINE__, #cond);                       \
               abort();                                                           \
           }                                                                      \
       }
   
   typedef symengine_exceptions_t CWRAPPER_OUTPUT_TYPE;
   
   typedef enum {
   #define SYMENGINE_INCLUDE_ALL
   #define SYMENGINE_ENUM(type, Class) type,
   #include "symengine/type_codes.inc"
   #undef SYMENGINE_ENUM
   #undef SYMENGINE_INCLUDE_ALL
       SYMENGINE_TypeID_Count
   } TypeID;
   
   typedef struct dcomplex {
       double real;
       double imag;
   } dcomplex;
   
   // The size of 'CRCPBasic_C' must be the same as CRCPBasic (which contains a
   // single RCP<const Basic> member) *and* they must have the same alignment
   // (because we allocate CRCPBasic into the memory occupied by this struct in
   // cwrapper.cpp). We cannot use C++ in this file, so we need to use C tools to
   // arrive at the correct size and alignment.  The size of the RCP object on
   // most platforms (with WITH_SYMENGINE_RCP on) should be just the size of the
   // 'T *ptr_' pointer that it contains (as there is no virtual function table)
   // and the alignment should also be of a pointer.  So we just put 'void *data'
   // as the only member of the struct, that should have the correct size and
   // alignment. With WITH_SYMENGINE_RCP off (i.e. using Teuchos::RCP), we have to
   // add additional members into the structure.
   //
   // However, this is checked at compile time in cwrapper.cpp, so if the size or
   // alignment is different on some platform, the compilation will fail --- in
   // that case one needs to modify the contents of this struct to adjust its size
   // and/or alignment.
   struct CRCPBasic_C {
       void *data;
   #if !defined(WITH_SYMENGINE_RCP)
       void *teuchos_handle;
       int teuchos_strength;
   #endif
   };
   
   //  CRCPBasic, which has the same size and alignment as RCP<const Basic> (see
   //  the above comment for details). That is then used by the user to allocate
   //  the memory needed for RCP<const Basic> on the stack. A 'basic' type should
   //  be initialized using basic_new_stack(), before any function is called.
   //  Assignment should be done only by using basic_assign(). Before the variable
   //  goes out of scope, basic_free_stack() must be called.
   //
   //  For C, define a dummy struct with the right size, so that it can be
   //  allocated on the stack. For C++, the CRCPBasic is declared in cwrapper.cpp.
   #ifdef __cplusplus
   typedef struct CRCPBasic basic_struct;
   #else
   typedef struct CRCPBasic_C basic_struct;
   #endif
   
   typedef basic_struct basic[1];
   
   // 'basic' type, this function initializes an RCP<const Basic> on the stack
   // allocated variable. The 's' variable must be freed using basic_free_stack()
   void basic_new_stack(basic s);
   void basic_free_stack(basic s);
   
   // Use these two functions to allocate and free 'basic' on a heap. The pointer
   // can then be used in all the other methods below (i.e. the methods that
   // accept 'basic s' work no matter if 's' is stack or heap allocated).
   basic_struct *basic_new_heap();
   void basic_free_heap(basic_struct *s);
   
   const char *symengine_version();
   
   
   void basic_const_set(basic s, const char *c);
   
   void basic_const_zero(basic s);
   void basic_const_one(basic s);
   void basic_const_minus_one(basic s);
   void basic_const_I(basic s);
   
   void basic_const_pi(basic s);
   void basic_const_E(basic s);
   void basic_const_EulerGamma(basic s);
   void basic_const_Catalan(basic s);
   void basic_const_GoldenRatio(basic s);
   
   void basic_const_infinity(basic s);
   void basic_const_neginfinity(basic s);
   void basic_const_complex_infinity(basic s);
   
   void basic_const_nan(basic s);
   
   CWRAPPER_OUTPUT_TYPE basic_assign(basic a, const basic b);
   
   CWRAPPER_OUTPUT_TYPE basic_parse(basic b, const char *str);
   CWRAPPER_OUTPUT_TYPE basic_parse2(basic b, const char *str, int convert_xor);
   
   TypeID basic_get_type(const basic s);
   TypeID basic_get_class_id(const char *c);
   char *basic_get_class_from_id(TypeID id);
   
   CWRAPPER_OUTPUT_TYPE symbol_set(basic s, const char *c);
   
   int number_is_zero(const basic s);
   int number_is_negative(const basic s);
   int number_is_positive(const basic s);
   int number_is_complex(const basic s);
   
   CWRAPPER_OUTPUT_TYPE integer_set_si(basic s, long i);
   CWRAPPER_OUTPUT_TYPE integer_set_ui(basic s, unsigned long i);
   #ifdef HAVE_SYMENGINE_GMP
   CWRAPPER_OUTPUT_TYPE integer_set_mpz(basic s, const mpz_t i);
   #endif
   CWRAPPER_OUTPUT_TYPE integer_set_str(basic s, const char *c);
   CWRAPPER_OUTPUT_TYPE real_double_set_d(basic s, double d);
   double real_double_get_d(const basic s);
   
   #ifdef HAVE_SYMENGINE_MPFR
   CWRAPPER_OUTPUT_TYPE real_mpfr_set_d(basic s, double d, int prec);
   CWRAPPER_OUTPUT_TYPE real_mpfr_set_str(basic s, const char *c, int prec);
   double real_mpfr_get_d(const basic s);
   CWRAPPER_OUTPUT_TYPE real_mpfr_set(basic s, mpfr_srcptr m);
   CWRAPPER_OUTPUT_TYPE real_mpfr_get(mpfr_ptr m, const basic s);
   mpfr_prec_t real_mpfr_get_prec(const basic s);
   #endif // HAVE_SYMENGINE_MPFR
   
   CWRAPPER_OUTPUT_TYPE complex_base_real_part(basic s, const basic com);
   CWRAPPER_OUTPUT_TYPE complex_base_imaginary_part(basic s, const basic com);
   
   signed long integer_get_si(const basic s);
   unsigned long integer_get_ui(const basic s);
   #ifdef HAVE_SYMENGINE_GMP
   CWRAPPER_OUTPUT_TYPE integer_get_mpz(mpz_t a, const basic s);
   #endif
   
   CWRAPPER_OUTPUT_TYPE rational_set(basic s, const basic i, const basic j);
   CWRAPPER_OUTPUT_TYPE rational_set_si(basic s, long i, long j);
   CWRAPPER_OUTPUT_TYPE rational_set_ui(basic s, unsigned long i, unsigned long j);
   #ifdef HAVE_SYMENGINE_GMP
   CWRAPPER_OUTPUT_TYPE rational_get_mpq(mpq_t a, const basic s);
   CWRAPPER_OUTPUT_TYPE rational_set_mpq(basic s, const mpq_t i);
   #endif
   
   CWRAPPER_OUTPUT_TYPE complex_set(basic s, const basic re, const basic im);
   CWRAPPER_OUTPUT_TYPE complex_set_rat(basic s, const basic re, const basic im);
   #ifdef HAVE_SYMENGINE_GMP
   CWRAPPER_OUTPUT_TYPE complex_set_mpq(basic s, const mpq_t re, const mpq_t im);
   #endif
   
   dcomplex complex_double_get(const basic s);
   
   CWRAPPER_OUTPUT_TYPE basic_add(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_sub(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_mul(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_div(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_pow(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_diff(basic s, const basic expr, const basic sym);
   int basic_eq(const basic a, const basic b);
   int basic_neq(const basic a, const basic b);
   
   CWRAPPER_OUTPUT_TYPE basic_expand(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_neg(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_abs(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_erf(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_erfc(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_sin(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_cos(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_tan(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_asin(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_acos(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_atan(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_csc(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_sec(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_cot(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_acsc(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_asec(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_acot(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_sinh(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_cosh(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_tanh(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_asinh(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_acosh(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_atanh(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_csch(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_sech(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_coth(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_acsch(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_asech(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_acoth(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_lambertw(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_zeta(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_dirichlet_eta(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_gamma(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_loggamma(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_sqrt(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_cbrt(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_exp(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE basic_log(basic s, const basic a);
   
   CWRAPPER_OUTPUT_TYPE basic_atan2(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_kronecker_delta(basic s, const basic a,
                                              const basic b);
   CWRAPPER_OUTPUT_TYPE basic_lowergamma(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_uppergamma(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_beta(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE basic_polygamma(basic s, const basic a, const basic b);
   
   char *basic_str(const basic s);
   char *basic_str_julia(const basic s);
   char *basic_str_mathml(const basic s);
   char *basic_str_latex(const basic s);
   char *basic_str_ccode(const basic s);
   char *basic_str_jscode(const basic s);
   void basic_str_free(char *s);
   
   int symengine_have_component(const char *c);
   
   int is_a_Number(const basic s);
   int is_a_Integer(const basic s);
   int is_a_Rational(const basic s);
   int is_a_Symbol(const basic s);
   int is_a_Complex(const basic s);
   int is_a_RealDouble(const basic c);
   int is_a_ComplexDouble(const basic c);
   int is_a_RealMPFR(const basic c);
   int is_a_ComplexMPC(const basic c);
   
   
   typedef struct CVectorInt CVectorInt;
   
   CVectorInt *vectorint_new();
   
   // 'data' must point to allocated memory of size 'size'. The function returns 0
   // if std::vector<int> can be initialized using placement new into 'data',
   // otherwise 1 if 'size' is too small or 2 if 'data' is not properly aligned.
   // No memory is leaked either way. Use vectorint_placement_new_check() to check
   // that the 'data' and 'size' is properly allocated and aligned. Use
   // vectorint_placement_new() to do the actual allocation.
   int vectorint_placement_new_check(void *data, size_t size);
   CVectorInt *vectorint_placement_new(void *data);
   
   void vectorint_placement_free(CVectorInt *self);
   
   void vectorint_free(CVectorInt *self);
   void vectorint_push_back(CVectorInt *self, int value);
   int vectorint_get(CVectorInt *self, int n);
   
   
   typedef struct CVecBasic CVecBasic;
   
   CVecBasic *vecbasic_new();
   void vecbasic_free(CVecBasic *self);
   CWRAPPER_OUTPUT_TYPE vecbasic_push_back(CVecBasic *self, const basic value);
   CWRAPPER_OUTPUT_TYPE vecbasic_get(CVecBasic *self, size_t n, basic result);
   CWRAPPER_OUTPUT_TYPE vecbasic_set(CVecBasic *self, size_t n, const basic s);
   CWRAPPER_OUTPUT_TYPE vecbasic_erase(CVecBasic *self, size_t n);
   size_t vecbasic_size(CVecBasic *self);
   
   CWRAPPER_OUTPUT_TYPE basic_max(basic s, CVecBasic *d);
   CWRAPPER_OUTPUT_TYPE basic_min(basic s, CVecBasic *d);
   
   
   typedef struct CDenseMatrix CDenseMatrix;
   typedef struct CSparseMatrix CSparseMatrix;
   
   CDenseMatrix *dense_matrix_new();
   CSparseMatrix *sparse_matrix_new();
   
   void dense_matrix_free(CDenseMatrix *self);
   CDenseMatrix *dense_matrix_new_vec(unsigned rows, unsigned cols, CVecBasic *l);
   CDenseMatrix *dense_matrix_new_rows_cols(unsigned r, unsigned c);
   
   void sparse_matrix_free(CSparseMatrix *self);
   
   CWRAPPER_OUTPUT_TYPE dense_matrix_set(CDenseMatrix *s, const CDenseMatrix *d);
   
   char *dense_matrix_str(const CDenseMatrix *s);
   CWRAPPER_OUTPUT_TYPE dense_matrix_rows_cols(CDenseMatrix *mat, unsigned r,
                                               unsigned c);
   CWRAPPER_OUTPUT_TYPE dense_matrix_get_basic(basic s, const CDenseMatrix *mat,
                                               unsigned long int r,
                                               unsigned long int c);
   CWRAPPER_OUTPUT_TYPE dense_matrix_set_basic(CDenseMatrix *mat,
                                               unsigned long int r,
                                               unsigned long int c, basic s);
   CWRAPPER_OUTPUT_TYPE sparse_matrix_get_basic(basic s, const CSparseMatrix *mat,
                                                unsigned long int r,
                                                unsigned long int c);
   CWRAPPER_OUTPUT_TYPE sparse_matrix_set_basic(CSparseMatrix *mat,
                                                unsigned long int r,
                                                unsigned long int c, basic s);
   CWRAPPER_OUTPUT_TYPE dense_matrix_det(basic s, const CDenseMatrix *mat);
   CWRAPPER_OUTPUT_TYPE dense_matrix_inv(CDenseMatrix *s, const CDenseMatrix *mat);
   CWRAPPER_OUTPUT_TYPE dense_matrix_transpose(CDenseMatrix *s,
                                               const CDenseMatrix *mat);
   CWRAPPER_OUTPUT_TYPE
   dense_matrix_submatrix(CDenseMatrix *s, const CDenseMatrix *mat,
                          unsigned long int r1, unsigned long int c1,
                          unsigned long int r2, unsigned long int c2,
                          unsigned long int r, unsigned long int c);
   CWRAPPER_OUTPUT_TYPE dense_matrix_row_join(CDenseMatrix *A,
                                              const CDenseMatrix *B);
   CWRAPPER_OUTPUT_TYPE dense_matrix_col_join(CDenseMatrix *A,
                                              const CDenseMatrix *B);
   CWRAPPER_OUTPUT_TYPE dense_matrix_row_del(CDenseMatrix *C, unsigned k);
   CWRAPPER_OUTPUT_TYPE dense_matrix_col_del(CDenseMatrix *C, unsigned k);
   
   unsigned long int dense_matrix_cols(const CDenseMatrix *s);
   unsigned long int dense_matrix_rows(const CDenseMatrix *s);
   CWRAPPER_OUTPUT_TYPE dense_matrix_add_matrix(CDenseMatrix *s,
                                                const CDenseMatrix *matA,
                                                const CDenseMatrix *matB);
   CWRAPPER_OUTPUT_TYPE dense_matrix_mul_matrix(CDenseMatrix *s,
                                                const CDenseMatrix *matA,
                                                const CDenseMatrix *matB);
   CWRAPPER_OUTPUT_TYPE dense_matrix_add_scalar(CDenseMatrix *s,
                                                const CDenseMatrix *matA,
                                                const basic b);
   CWRAPPER_OUTPUT_TYPE dense_matrix_mul_scalar(CDenseMatrix *s,
                                                const CDenseMatrix *matA,
                                                const basic b);
   CWRAPPER_OUTPUT_TYPE dense_matrix_LU(CDenseMatrix *l, CDenseMatrix *u,
                                        const CDenseMatrix *mat);
   CWRAPPER_OUTPUT_TYPE dense_matrix_LDL(CDenseMatrix *l, CDenseMatrix *d,
                                         const CDenseMatrix *mat);
   CWRAPPER_OUTPUT_TYPE dense_matrix_FFLU(CDenseMatrix *lu,
                                          const CDenseMatrix *mat);
   CWRAPPER_OUTPUT_TYPE dense_matrix_FFLDU(CDenseMatrix *l, CDenseMatrix *d,
                                           CDenseMatrix *u,
                                           const CDenseMatrix *mat);
   CWRAPPER_OUTPUT_TYPE dense_matrix_LU_solve(CDenseMatrix *x,
                                              const CDenseMatrix *A,
                                              const CDenseMatrix *b);
   CWRAPPER_OUTPUT_TYPE dense_matrix_ones(CDenseMatrix *s, unsigned long int r,
                                          unsigned long int c);
   CWRAPPER_OUTPUT_TYPE dense_matrix_zeros(CDenseMatrix *s, unsigned long int r,
                                           unsigned long int c);
   CWRAPPER_OUTPUT_TYPE dense_matrix_diag(CDenseMatrix *s, CVecBasic *d,
                                          long int k);
   CWRAPPER_OUTPUT_TYPE dense_matrix_eye(CDenseMatrix *s, unsigned long int N,
                                         unsigned long int M, int k);
   CWRAPPER_OUTPUT_TYPE dense_matrix_diff(CDenseMatrix *result,
                                          const CDenseMatrix *A, basic const x);
   CWRAPPER_OUTPUT_TYPE dense_matrix_jacobian(CDenseMatrix *result,
                                              const CDenseMatrix *A,
                                              const CDenseMatrix *x);
   
   void sparse_matrix_init(CSparseMatrix *s);
   void sparse_matrix_rows_cols(CSparseMatrix *s, unsigned long int r,
                                unsigned long int c);
   char *sparse_matrix_str(const CSparseMatrix *s);
   
   int is_a_DenseMatrix(const CDenseMatrix *c);
   int is_a_SparseMatrix(const CSparseMatrix *c);
   
   int dense_matrix_eq(CDenseMatrix *lhs, CDenseMatrix *rhs);
   int sparse_matrix_eq(CSparseMatrix *lhs, CSparseMatrix *rhs);
   
   
   typedef struct CSetBasic CSetBasic;
   
   CSetBasic *setbasic_new();
   void setbasic_free(CSetBasic *self);
   int setbasic_insert(CSetBasic *self, const basic value);
   void setbasic_get(CSetBasic *self, int n, basic result);
   int setbasic_find(CSetBasic *self, basic value);
   int setbasic_erase(CSetBasic *self, const basic value);
   size_t setbasic_size(CSetBasic *self);
   
   
   typedef struct CMapBasicBasic CMapBasicBasic;
   
   CMapBasicBasic *mapbasicbasic_new();
   void mapbasicbasic_free(CMapBasicBasic *self);
   void mapbasicbasic_insert(CMapBasicBasic *self, const basic key,
                             const basic mapped);
   int mapbasicbasic_get(CMapBasicBasic *self, const basic key, basic mapped);
   size_t mapbasicbasic_size(CMapBasicBasic *self);
   
   // -------------------------------------
   
   CWRAPPER_OUTPUT_TYPE basic_get_args(const basic self, CVecBasic *args);
   CWRAPPER_OUTPUT_TYPE basic_free_symbols(const basic self, CSetBasic *symbols);
   CWRAPPER_OUTPUT_TYPE basic_function_symbols(CSetBasic *symbols,
                                               const basic self);
   size_t basic_hash(const basic self);
   CWRAPPER_OUTPUT_TYPE basic_subs(basic s, const basic e,
                                   const CMapBasicBasic *mapbb);
   CWRAPPER_OUTPUT_TYPE basic_subs2(basic s, const basic e, const basic a,
                                    const basic b);
   
   CWRAPPER_OUTPUT_TYPE function_symbol_set(basic s, const char *c,
                                            const CVecBasic *arg);
   char *function_symbol_get_name(const basic b);
   CWRAPPER_OUTPUT_TYPE basic_coeff(basic c, const basic b, const basic x,
                                    const basic n);
   
   
   CWRAPPER_OUTPUT_TYPE vecbasic_linsolve(CVecBasic *sol, const CVecBasic *sys,
                                          const CVecBasic *sym);
   CWRAPPER_OUTPUT_TYPE basic_solve_poly(CSetBasic *r, const basic f,
                                         const basic s);
   
   
   char *ascii_art_str();
   
   CWRAPPER_OUTPUT_TYPE ntheory_gcd(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE ntheory_lcm(basic s, const basic a, const basic b);
   CWRAPPER_OUTPUT_TYPE ntheory_gcd_ext(basic g, basic s, basic t, const basic a,
                                        const basic b);
   CWRAPPER_OUTPUT_TYPE ntheory_nextprime(basic s, const basic a);
   CWRAPPER_OUTPUT_TYPE ntheory_mod(basic s, const basic n, const basic d);
   CWRAPPER_OUTPUT_TYPE ntheory_quotient(basic s, const basic n, const basic d);
   CWRAPPER_OUTPUT_TYPE ntheory_quotient_mod(basic q, basic r, const basic n,
                                             const basic d);
   CWRAPPER_OUTPUT_TYPE ntheory_mod_f(basic s, const basic n, const basic d);
   CWRAPPER_OUTPUT_TYPE ntheory_quotient_f(basic s, const basic n, const basic d);
   CWRAPPER_OUTPUT_TYPE ntheory_quotient_mod_f(basic q, basic r, const basic n,
                                               const basic d);
   int ntheory_mod_inverse(basic b, const basic a, const basic m);
   CWRAPPER_OUTPUT_TYPE ntheory_fibonacci(basic s, unsigned long a);
   CWRAPPER_OUTPUT_TYPE ntheory_fibonacci2(basic g, basic s, unsigned long a);
   CWRAPPER_OUTPUT_TYPE ntheory_lucas(basic s, unsigned long a);
   CWRAPPER_OUTPUT_TYPE ntheory_lucas2(basic g, basic s, unsigned long a);
   CWRAPPER_OUTPUT_TYPE ntheory_binomial(basic s, const basic a, unsigned long b);
   CWRAPPER_OUTPUT_TYPE ntheory_factorial(basic s, unsigned long n);
   CWRAPPER_OUTPUT_TYPE basic_evalf(basic s, const basic b, unsigned long bits,
                                    int real);
   
   CWRAPPER_OUTPUT_TYPE basic_as_numer_denom(basic numer, basic denom,
                                             const basic x);
   
   typedef struct CLambdaRealDoubleVisitor CLambdaRealDoubleVisitor;
   CLambdaRealDoubleVisitor *lambda_real_double_visitor_new();
   void lambda_real_double_visitor_init(CLambdaRealDoubleVisitor *self,
                                        const CVecBasic *args,
                                        const CVecBasic *exprs, int perform_cse);
   void lambda_real_double_visitor_call(CLambdaRealDoubleVisitor *self,
                                        double *const outs,
                                        const double *const inps);
   void lambda_real_double_visitor_free(CLambdaRealDoubleVisitor *self);
   
   #ifdef HAVE_SYMENGINE_LLVM
   // double
   typedef struct CLLVMDoubleVisitor CLLVMDoubleVisitor;
   CLLVMDoubleVisitor *llvm_double_visitor_new();
   void llvm_double_visitor_init(CLLVMDoubleVisitor *self, const CVecBasic *args,
                                 const CVecBasic *exprs, int perform_cse,
                                 int opt_level);
   void llvm_double_visitor_call(CLLVMDoubleVisitor *self, double *const outs,
                                 const double *const inps);
   void llvm_double_visitor_free(CLLVMDoubleVisitor *self);
   // float
   typedef struct CLLVMFloatVisitor CLLVMFloatVisitor;
   CLLVMFloatVisitor *llvm_float_visitor_new();
   void llvm_float_visitor_init(CLLVMFloatVisitor *self, const CVecBasic *args,
                                const CVecBasic *exprs, int perform_cse,
                                int opt_level);
   void llvm_float_visitor_call(CLLVMFloatVisitor *self, float *const outs,
                                const float *const inps);
   void llvm_float_visitor_free(CLLVMFloatVisitor *self);
   
   #ifdef SYMENGINE_HAVE_LLVM_LONG_DOUBLE
   // long double
   typedef struct CLLVMLongDoubleVisitor CLLVMLongDoubleVisitor;
   CLLVMLongDoubleVisitor *llvm_long_double_visitor_new();
   void llvm_long_double_visitor_init(CLLVMLongDoubleVisitor *self,
                                      const CVecBasic *args,
                                      const CVecBasic *exprs, int perform_cse,
                                      int opt_level);
   void llvm_long_double_visitor_call(CLLVMLongDoubleVisitor *self,
                                      long double *const outs,
                                      const long double *const inps);
   void llvm_long_double_visitor_free(CLLVMLongDoubleVisitor *self);
   #endif
   #endif
   
   CWRAPPER_OUTPUT_TYPE basic_cse(CVecBasic *replacement_syms,
                                  CVecBasic *replacement_exprs,
                                  CVecBasic *reduced_exprs,
                                  const CVecBasic *exprs);
   
   void symengine_print_stack_on_segfault();
   
   #ifdef __cplusplus
   }
   #endif
   #endif
