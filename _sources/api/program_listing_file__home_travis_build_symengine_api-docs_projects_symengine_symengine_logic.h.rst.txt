
.. _program_listing_file__home_travis_build_symengine_api-docs_projects_symengine_symengine_logic.h:

Program Listing for File logic.h
================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_symengine_api-docs_projects_symengine_symengine_logic.h>` (``/home/travis/build/symengine/api-docs/projects/symengine/symengine/logic.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef SYMENGINE_LOGIC_H
   #define SYMENGINE_LOGIC_H
   
   #include <symengine/basic.h>
   #include <symengine/sets.h>
   
   namespace SymEngine
   {
   typedef std::set<RCP<const Boolean>, RCPBasicKeyLess> set_boolean;
   typedef std::vector<RCP<const Boolean>> vec_boolean;
   
   // Parent class for expressing boolean statements
   class Boolean : public Basic
   {
   public:
       virtual RCP<const Boolean> logical_not() const;
   };
   
   // Booleans True and False
   class BooleanAtom : public Boolean
   {
   private:
       bool b_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_BOOLEAN_ATOM)
       BooleanAtom(bool b);
       hash_t __hash__() const;
       bool get_val() const;
       virtual vec_basic get_args() const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   extern SYMENGINE_EXPORT RCP<const BooleanAtom> boolTrue;
   extern SYMENGINE_EXPORT RCP<const BooleanAtom> boolFalse;
   
   inline RCP<const BooleanAtom> boolean(bool b)
   {
       return b ? boolTrue : boolFalse;
   }
   
   // Represents `expr_` is inside set `set_`
   // `set_` can be any `Set` including `Interval`, `FiniteSet`
   class Contains : public Boolean
   {
   private:
       RCP<const Basic> expr_;
       RCP<const Set> set_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_CONTAINS)
       Contains(const RCP<const Basic> &expr, const RCP<const Set> &set);
       hash_t __hash__() const;
       RCP<const Basic> get_expr() const;
       RCP<const Set> get_set() const;
       virtual vec_basic get_args() const;
       virtual bool __eq__(const Basic &o) const;
       RCP<const Basic> create(const RCP<const Basic> &lhs,
                               const RCP<const Set> &rhs) const;
       virtual int compare(const Basic &o) const;
   };
   
   RCP<const Boolean> contains(const RCP<const Basic> &expr,
                               const RCP<const Set> &set);
   
   typedef std::vector<std::pair<RCP<const Basic>, RCP<const Boolean>>>
       PiecewiseVec;
   
   // Represents a piecewise function
   // Keeps a vector of (Expr, Condition) pairs
   class Piecewise : public Basic
   {
   private:
       PiecewiseVec vec_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_PIECEWISE)
       Piecewise(PiecewiseVec &&vec);
       hash_t __hash__() const;
       const PiecewiseVec &get_vec() const;
       virtual vec_basic get_args() const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
   };
   
   // Vec is vector of pairs of RCP<const Basic> and RCP<const Boolean> to
   // represent (Expr, Condition) pairs
   inline RCP<const Basic> piecewise(PiecewiseVec &&vec)
   {
       return make_rcp<Piecewise>(std::move(vec));
   }
   
   class And : public Boolean
   {
   private:
       set_boolean container_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_AND)
       And(const set_boolean &s);
       bool is_canonical(const set_boolean &container_);
       hash_t __hash__() const;
       virtual vec_basic get_args() const;
       RCP<const Basic> create(const set_boolean &a) const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
       const set_boolean &get_container() const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   class Or : public Boolean
   {
   private:
       set_boolean container_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_OR)
       Or(const set_boolean &s);
       bool is_canonical(const set_boolean &container_);
       hash_t __hash__() const;
       virtual vec_basic get_args() const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
       const set_boolean &get_container() const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   class Not : public Boolean
   {
   private:
       RCP<const Boolean> arg_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_NOT)
       Not(const RCP<const Boolean> &s);
       bool is_canonical(const RCP<const Boolean> &s);
       hash_t __hash__() const;
       virtual vec_basic get_args() const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
       RCP<const Boolean> get_arg() const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   class Xor : public Boolean
   {
   private:
       vec_boolean container_;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_XOR)
       Xor(const vec_boolean &s);
       bool is_canonical(const vec_boolean &container_);
       hash_t __hash__() const;
       virtual vec_basic get_args() const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
       const vec_boolean &get_container() const;
   };
   
   class Relational : public TwoArgBasic<Boolean>
   {
   public:
       Relational(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
       virtual bool is_canonical(const RCP<const Basic> &lhs,
                                 const RCP<const Basic> &rhs) const;
   };
   
   class Equality : public Relational
   {
   public:
       IMPLEMENT_TYPEID(SYMENGINE_EQUALITY)
       Equality(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
       virtual RCP<const Basic> create(const RCP<const Basic> &lhs,
                                       const RCP<const Basic> &rhs) const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   class Unequality : public Relational
   {
   public:
       IMPLEMENT_TYPEID(SYMENGINE_UNEQUALITY)
       Unequality(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
       virtual RCP<const Basic> create(const RCP<const Basic> &lhs,
                                       const RCP<const Basic> &rhs) const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   class LessThan : public Relational
   {
   public:
       IMPLEMENT_TYPEID(SYMENGINE_LESSTHAN)
       LessThan(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
       virtual RCP<const Basic> create(const RCP<const Basic> &lhs,
                                       const RCP<const Basic> &rhs) const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   class StrictLessThan : public Relational
   {
   public:
       IMPLEMENT_TYPEID(SYMENGINE_STRICTLESSTHAN)
       StrictLessThan(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
       virtual RCP<const Basic> create(const RCP<const Basic> &lhs,
                                       const RCP<const Basic> &rhs) const;
       virtual RCP<const Boolean> logical_not() const;
   };
   
   inline bool is_a_Relational(const Basic &b)
   {
       return (b.get_type_code() == SYMENGINE_EQUALITY
               || b.get_type_code() == SYMENGINE_UNEQUALITY
               || b.get_type_code() == SYMENGINE_LESSTHAN
               || b.get_type_code() == SYMENGINE_STRICTLESSTHAN);
   }
   
   inline bool is_a_Boolean(const Basic &b)
   {
       return (b.get_type_code() == SYMENGINE_BOOLEAN_ATOM
               || b.get_type_code() == SYMENGINE_CONTAINS
               || b.get_type_code() == SYMENGINE_AND
               || b.get_type_code() == SYMENGINE_OR
               || b.get_type_code() == SYMENGINE_NOT
               || b.get_type_code() == SYMENGINE_XOR || is_a_Relational(b));
   }
   
   RCP<const Boolean> Eq(const RCP<const Basic> &lhs);
   RCP<const Boolean> Eq(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
   RCP<const Boolean> Ne(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
   RCP<const Boolean> Ge(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
   RCP<const Boolean> Gt(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
   RCP<const Boolean> Le(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
   RCP<const Boolean> Lt(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs);
   
   RCP<const Boolean> logical_and(const set_boolean &s);
   RCP<const Boolean> logical_nand(const set_boolean &s);
   RCP<const Boolean> logical_or(const set_boolean &s);
   RCP<const Boolean> logical_not(const RCP<const Boolean> &s);
   RCP<const Boolean> logical_nor(const set_boolean &s);
   RCP<const Boolean> logical_xor(const vec_boolean &s);
   RCP<const Boolean> logical_xnor(const vec_boolean &s);
   } // SymEngine
   
   #endif
