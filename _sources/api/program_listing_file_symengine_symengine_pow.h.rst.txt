
.. _program_listing_file_symengine_symengine_pow.h:

Program Listing for File pow.h
==============================

|exhale_lsh| :ref:`Return to documentation for file <file_symengine_symengine_pow.h>` (``symengine/symengine/pow.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef SYMENGINE_POW_H
   #define SYMENGINE_POW_H
   
   #include <symengine/functions.h>
   #include <symengine/mul.h>
   #include <symengine/ntheory.h>
   #include <symengine/constants.h>
   
   namespace SymEngine
   {
   
   class Pow : public Basic
   {
   private:
       RCP<const Basic> base_, exp_; 
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_POW)
       Pow(const RCP<const Basic> &base, const RCP<const Basic> &exp);
       virtual hash_t __hash__() const;
       virtual bool __eq__(const Basic &o) const;
       virtual int compare(const Basic &o) const;
       bool is_canonical(const Basic &base, const Basic &exp) const;
       inline RCP<const Basic> get_base() const
       {
           return base_;
       }
       inline RCP<const Basic> get_exp() const
       {
           return exp_;
       }
   
       virtual vec_basic get_args() const;
   };
   
   RCP<const Basic> pow(const RCP<const Basic> &a, const RCP<const Basic> &b);
   
   RCP<const Basic> exp(const RCP<const Basic> &x);
   
   void multinomial_coefficients(unsigned m, unsigned n, map_vec_uint &r);
   void multinomial_coefficients_mpz(unsigned m, unsigned n, map_vec_mpz &r);
   RCP<const Basic> pow_expand(const RCP<const Pow> &self);
   inline RCP<const Basic> sqrt(const RCP<const Basic> &x)
   {
       return pow(x, div(one, integer(2)));
   }
   inline RCP<const Basic> cbrt(const RCP<const Basic> &x)
   {
       return pow(x, div(one, integer(3)));
   }
   
   } // SymEngine
   
   #endif
