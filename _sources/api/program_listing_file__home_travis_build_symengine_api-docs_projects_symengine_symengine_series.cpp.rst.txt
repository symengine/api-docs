
.. _program_listing_file__home_travis_build_symengine_api-docs_projects_symengine_symengine_series.cpp:

Program Listing for File series.cpp
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_symengine_api-docs_projects_symengine_symengine_series.cpp>` (``/home/travis/build/symengine/api-docs/projects/symengine/symengine/series.cpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #include <symengine/series_visitor.h>
   
   namespace SymEngine
   {
   
   bool needs_symbolic_constants(const RCP<const Basic> &ex,
                                 const RCP<const Symbol> &var)
   {
       NeedsSymbolicExpansionVisitor v;
       return v.apply(*ex, var);
   }
   
   RCP<const SeriesCoeffInterface> series(const RCP<const Basic> &ex,
                                          const RCP<const Symbol> &var,
                                          unsigned int prec)
   {
       auto syms = free_symbols(*ex);
   #ifdef HAVE_SYMENGINE_PIRANHA
       if (prec == 0)
           return make_rcp<const UPSeriesPiranha>(p_expr{Expression()},
                                                  var->get_name(), prec);
       if (not has_symbol(*ex, *var))
           return make_rcp<const UPSeriesPiranha>(p_expr{Expression(ex)},
                                                  var->get_name(), prec);
       if (is_a<Symbol>(*ex))
           return make_rcp<const UPSeriesPiranha>(p_expr{Expression(ex)},
                                                  var->get_name(), prec);
   
       if (syms.size() == 1) {
           if (needs_symbolic_constants(ex, var))
               return UPSeriesPiranha::series(ex, var->get_name(), prec);
   #ifdef HAVE_SYMENGINE_FLINT
           return URatPSeriesFlint::series(ex, var->get_name(), prec);
   #else
           return URatPSeriesPiranha::series(ex, var->get_name(), prec);
   #endif
       }
   
       return UPSeriesPiranha::series(ex, var->get_name(), prec);
   #elif defined(HAVE_SYMENGINE_FLINT)
       if (prec == 0)
           return URatPSeriesFlint::series(integer(0), var->get_name(), prec);
   
       if (syms.size() > 1)
           return UnivariateSeries::series(ex, var->get_name(), prec);
   
       if (needs_symbolic_constants(ex, var))
           return UnivariateSeries::series(ex, var->get_name(), prec);
       return URatPSeriesFlint::series(ex, var->get_name(), prec);
   #else
       return UnivariateSeries::series(ex, var->get_name(), prec);
   #endif
   }
   
   RCP<const SeriesCoeffInterface> series_invfunc(const RCP<const Basic> &ex,
                                                  const RCP<const Symbol> &var,
                                                  unsigned int prec)
   {
   #ifdef HAVE_SYMENGINE_PIRANHA
       if (prec == 0)
           return make_rcp<const UPSeriesPiranha>(p_expr{Expression()},
                                                  var->get_name(), prec);
       if (is_a<Symbol>(*ex))
           return make_rcp<const UPSeriesPiranha>(p_expr{Expression(ex)},
                                                  var->get_name(), prec);
   
       return make_rcp<const UPSeriesPiranha>(
           UPSeriesPiranha::series_reverse(
               UPSeriesPiranha::series(ex, var->get_name(), prec)->get_poly(),
               p_expr(var->get_name()), prec),
           var->get_name(), prec);
   
   #else
       throw SymEngineException("Series reversion is supported only with Piranha");
   #endif
   }
   
   } // SymEngine
