
.. _program_listing_file__home_travis_build_symengine_api-docs_projects_symengine_symengine_infinity.h:

Program Listing for File infinity.h
===================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_travis_build_symengine_api-docs_projects_symengine_symengine_infinity.h>` (``/home/travis/build/symengine/api-docs/projects/symengine/symengine/infinity.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   
   #ifndef SYMENGINE_INFINITY_H
   #define SYMENGINE_INFINITY_H
   
   #include <symengine/basic.h>
   #include <symengine/number.h>
   #include <symengine/integer.h>
   #include <symengine/mul.h>
   
   namespace SymEngine
   {
   
   class Infty : public Number
   {
       RCP<const Number> _direction;
   
   public:
       IMPLEMENT_TYPEID(SYMENGINE_INFTY)
       Infty(const RCP<const Number> &direction);
       Infty(const Infty &inf);
       static RCP<const Infty> from_direction(const RCP<const Number> &direction);
       static RCP<const Infty> from_int(const int val);
   
       bool is_canonical(const RCP<const Number> &num) const;
       hash_t __hash__() const;
   
       // Implement these
       bool __eq__(const Basic &o) const;
       int compare(const Basic &o) const;
   
       virtual vec_basic get_args() const
       {
           return {_direction};
       }
   
       inline bool is_zero() const
       {
           return false;
       }
       inline bool is_one() const
       {
           return false;
       }
       inline bool is_minus_one() const
       {
           return false;
       }
   
       inline virtual bool is_exact() const
       {
           return false;
       }
       // //! Get `Evaluate` singleton to evaluate numerically
       virtual Evaluate &get_eval() const;
   
       inline RCP<const Number> get_direction() const
       {
           return _direction;
       }
   
       bool is_unsigned_infinity() const;
       bool is_positive_infinity() const;
       bool is_negative_infinity() const;
   
       inline bool is_positive() const
       {
           return is_positive_infinity();
       }
   
       inline bool is_negative() const
       {
           return is_negative_infinity();
       }
   
       inline bool is_complex() const
       {
           return is_unsigned_infinity();
       }
       virtual RCP<const Basic> conjugate() const;
   
       // Think about it again
       RCP<const Number> add(const Number &other) const;
       RCP<const Number> mul(const Number &other) const;
       RCP<const Number> div(const Number &other) const;
       RCP<const Number> pow(const Number &other) const;
       RCP<const Number> rpow(const Number &other) const;
   };
   
   inline RCP<const Infty> infty(int n = 1)
   {
       return make_rcp<Infty>(integer(n));
   }
   
   RCP<const Infty> infty(const RCP<const Number> &direction);
   
   } // SymEngine
   #endif
